# 四种引用类型

强引用: Java中最常见的引用类型. 比如new了一个对象, 然后通过赋值运算符赋值给了一个变量, 那么这个变量就强引用了这个对象. 强引用的特点就是**<font style="color:blue">沿着 GC Root 的引用链能够找到, 那就不会被垃圾回收</font>**

只有所有GC Root对象都不通过强引用引用该对象, 该对象才能被垃圾回收



软引用: 如果一个对象**只被软引用关联, JVM在垃圾回收时会判断当前内存是否紧张**. **<font style="color:blue">如果内存紧张, 就会回收软引用对象; 若内存充足, 则保留该对象</font>**

另外软引用对象被回收后, 因为软引用自身也是一个对象, 所以**可以配合引用队列来释放软引用自身**. 如果在它创建时分配了一个引用队列, 那么当它引用的对象被回收时, 软引用就会进入这个队列 (弱引用也是同理)

- **因为无论是软引用还是弱引用, 自身也要占用一定的内存**. 如果要对它们占用的内存进行释放就需要使用引用队列找到它们

**<font style="color:blue">软引用和弱引用既可以配合引用队列使用, 也可以不配合 </font>**(**虚引用和终结器引用必须配合**)

虽然说是可以不配合引用队列, 但配合引用队列使用的话当被引用的对象被垃圾回收后开发者可以及时得知, 从而可以及时地清理引用对象自身, 避免其长期留在缓存或集合中造成内存泄漏问题



弱引用: 如果一个对象只被弱引用关联, 那么在垃圾回收时, **<font style="color:blue">无论内存是否充足, 都会回收弱引用对象</font>**

就像刚才提到过的, 弱引用也可以配合引用队列来释放弱引用自身



虚引用: **主要用于在对象真正被回收之后执行资源释放逻辑. 必须配合引用队列使用**, 最常见的应用场景是与ByteBuffer一起使用

被引用对象回收时, 会将虚引用入队, 开发者可以在后台线程中监听该队列并执行清理逻辑



还有一个比较少见的终结器引用, 当对象重写了 `finalize()` 终结方法并且没有强引用引用要被垃圾回收时, 就是靠终结器引用调用这个方法

JVM 在识别到某对象重写了 `finalize()` 后, 会自动创建一个 `FinalReference` 对象来追踪该实例, 并关联到一个引用队列, 以便在垃圾回收时进行后续处理

**在垃圾回收时, 终结器引用先是入队(此时被引用的对象暂时还没有被回收),** 之后再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 `finalize()` 方法, **<font style="color:blue">然后在第二次 GC 时才能回收被引用对象</font>**

但**<font style="color:blue">处理终结器引用队列的线程优先级很低, 执行的机会很少</font>** -- 可能造成对象的 finalize 方法得不到调用, 内存迟迟不能释放, **因此不推荐使用该方法来释放资源**

## 什么是GC Root, GC Root对象有哪些

**GC Root 是垃圾回收时作为"根节点"的一组特殊对象**, JVM 会从这些对象出发, 沿着引用链向下搜索所有可达对象. 如果一个对象从 GC Root 出发"不可达", 就会被判定为**垃圾**, 也就可以被垃圾回收

> 这种方式也叫做可达性分析



接下来再说哪些对象算 GC Root

首先从JVM实现角度出发有四个固定入口, 分别是:

+ (1)**系统类, 由启动类加载器加载的核心类**, 如 Object,String 等 (System Class)

+ (2) Java中调用的操作系统方法在执行时引用的 Java 对象 (Native Stack)
+ (3) 正在被加锁的对象 (Busy Monitor)
+ (4) 正在活动的线程, 也就是**<font style="color:blue">活动栈帧内局部变量引用的对象</font>**. **另外方法参数也是根对象, 因为它们被存储在栈帧的局部变量表中**, 与局部变量一样属于活动线程栈中的引用对象 (Thread)

**此外在平时开发中常说的GC Root还包括静态字段、常量池中的对象、类加载器和已加载类的Class对象**, 它们在可达性分析中也同样被认为是有效的根































