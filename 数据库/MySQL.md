# 内连接; 左连接和右连接的区别

内连接 (INNER JOIN)

- 只返回左右表中**<font style="color:blue">都满足连接条件</font>**的匹配行, 也就是说两张表都存在对应记录时, 才返回结果

左连接 (LEFT JOIN / LEFT OUTER JOIN)

- **左连接会返回左表的所有行; 如果某一行在右表中能根据ON条件找到对应的匹配行就合并显示**; **<font style="color:blue">如果找不到匹配行, 则右表的字段用`NULL`补上</font>**

右连接 (RIGHT JOIN / RIGHT OUTER JOIN)

- 右连接就是返回右表的所有行; 如果某一行在左表中能根据`ON`条件找到对应的匹配行就合并显示; 如果找不到匹配行, 则左表中的字段用 NULL 补上

----

再补充一个全外连接 (FULL OUTER JOIN)

**<font style="color:blue">注: MySQL 不支持全外连接, 需要使用 UNION 来模拟</font>**

> 把左表和右表中能通过`ON`条件配对的行合并成一行
>
> **对于不能配对成功的行(即孤立行), 仍然保留**, 但未匹配一侧的列补`NULL`

**全外连接仍然基于 ON 条件做匹配, 只不过不舍弃任何一边的未匹配记录**; 而笛卡尔积根本不管匹不匹配, 直接组合所有行



# 线上SQL执行比较慢怎么排查

**先用慢查询日志判断是哪些SQL执行比较慢, <font style="color:blue">它会默认记录执行时间超过10秒的语句, 这个时间由一个叫 long_query_time 的参数控制</font>**, 可以修改它来调整"慢查询"的判定标准

**但是<font style="color:blue">MySQL的慢查询日志是默认关闭的</font>, 需要手动开启**

一种方式是临时开启, 通过命令的方式设置

```sql
# 设置后新开的连接中慢查询日志就会生效, 但是服务重启后就失效
SET GLOBAL slow_query_log = ON; -- 也可以设为1
SET GLOBAL long_query_time = 1; -- 单位是秒
```

**另一种就是永久开启, 通过写入配置文件的方式设置**

编辑 `/etc/my.cnf`(Linux) 或  `my.ini`(Windows)添加

```ini
slow_query_log = 1
long_query_time = 1
# 慢日志文件默认存储在 /var/lib/mysql 文件夹中
slow_query_log_file = /var/log/mysql/slow.log  # 或你想放的位置
```

**<font style="color:blue">设置完成后通过 `systemctl restart mysqld` 命令重启MySQL服务器</font>** (Windows系统就使用 `net stop / start mysql80` 的方式重启)

+ **配置完成后, 慢查询日志就只会记录执行时间超过预设时间的SQL**. 然后通过慢查询日志就可以定位出执行效率比较低的SQL, 从而有针对性的进行优化



因为有了具体的SQL语句之后, 就可以通过 explain 命令来分析为什么查询的慢

通过 explain 命令可以得知 MySQL 是如何执行该 SQL 语句的信息, 比如是不是走了全表扫描; 用没用索引以及用了哪些索引; 以及扫了多少行等



## 讲一下explain

参考博客: https://blog.csdn.net/qq10250507350/article/details/140027211

EXPLAIN 是 MySQL 提供的一个命令, **<font style="color:blue">用于查看 SQL 语句的执行计划</font>**

**其中有几个需要重点关注的列**

- type: 表示 MySQL 在执行这条SQL时访问表的方式, 也可以理解为**数据访问策略**. 性能由好到坏的取值依次是

  - NULL: 不访问任何表 (比如 `select 1`)
  - SYSTEM: 表中只有一行数据或者是空表, 不需要匹配条件就可以直接返回
  - CONST: 单表查询且表中最多只有一条匹配记录 **(即主键或唯一索引的等值匹配)**
  - **EQ_REF: 多表连接时**, 使用主键或者非空唯一键进行等值匹配, 每次只匹配一行
  - **<font style="color:blue">REF: 使用普通索引进行等值匹配, 可能匹配多行</font>** (没有主键和唯一索引的要求)
  - **RANGE: 用索引进行范围扫描, 比如 BETWEEN、> 、<、IN 等**
  - INDEX: 全索引扫描. 当查询的字段全部来自某个二级索引(即覆盖索引), 但是没有 WHERE 过滤条件, 读取数据时**是从"二级索引"中按顺序一行一行读的**, 性能上略优于 ALL
  - ALL: 全表扫描, 说明索引没用上或压根没有索引. 出现 ALL 时一般需要考虑加索引或改写 SQL 了



- **<font style="color:blue">key: 实际使用的索引</font>**. 如果是 NULL, 说明 SQL 的写法让索引失效了



- key_len: 表示在执行 SQL 时, **实际用于索引查找的字段所占字节数, <font style="color:blue">这个值是索引字段的最大可能长度</font>**, 并非实际使用长度 (当字段允许为 NULL 时, 会比不允许的情况大 1 个字节)

  - **<font style="color:blue">该字段只计算 where 条件用到的索引长度</font>**, 排序和分组就算用到了索引也不会计算到该字段中

  - **一般用于判断联合索引中有多少字段被命中了**



- rows: MySQL 预计需要扫描多少行数据, 才能完成这一步查询操作. 这是一个估算值, 可能并不总是准确的, 但即使这样它也是**判断 SQL 是否"扫了太多行"的关键指标**



- Extra: 提供了**关于查询执行过程的附加信息**, 常见的取值有:

  - Using where: 查询需要根据 WHERE 子句对数据进行进一步的过滤, 通常是因为索引未完全满足查询条件. 也就是查询条件部分使用了索引, 但仍需在扫描结果中进一步过滤 

  ```mysql
  SELECT * FROM users WHERE email = 'test@example.com' AND age > 30;
  # 如果 email 有索引, 但 age 没有索引, 则会显示 Using where
  ```

  - Using index: 查询的数据完全在索引里, 不需要进行回表查询 (也就是"覆盖索引")
  - Using filesort: MySQL发现结果**需要排序, 但无法用索引排序**, 数据较小时从内存排序, 否则需要在磁盘完成排序. **<font style="color:blue">通常是因为 ORDER BY 语句中的列没有使用索引</font>**
  - Using temporary: **<font style="color:blue">查询中用了临时表来保存中间结果</font>**, 说明 MySQL 会在内存或磁盘中创建临时表来执行操作, 这是额外的资源开销
    - 通常出现在复杂的 GROUP BY 或 ORDER BY 查询中, 尤其是这些字段未被索引覆盖时
  - Using index condition:  MySQL 5.6+ 版本引入的, **表示先按条件过滤索引, 过滤完索引后找到所有符合索引条件的数据行, 随后用 WHERE 子句中的其他条件去过滤这些数据行**
    - 这个机制仅在**查询字段不被索引完全覆盖**时才会出现
  - Distinct: 优化器检测到查询中的 DISTINCT 语义, 仅读取符合条件的第一条记录



除此之外还有一些其它不太需要关注的字段比如

- id: select 查询的序列号. **id 相同执行顺序从上到下(<font style="color:blue">大多数情况下 id 相同的几行就是在执行多表查询操作</font>)**; i**d不同值越大越先执行(即先执行子查询语句)**



- select_type: **表示查询的类型**, 下面列出一些常见的取值 (并非所有)
  - SIMPLE -- 简单表, 即不使用表连接或者子查询
  - PRIMARY -- 主查询. 也就是最外层的查询; SUBQUERY -- 子查询中的第一个 select 语句
  - UNION -- **UNION 中的第二个或者后面的查询语句**
  - DERIVED -- from 子句中出现的子查询, 也叫做派生表



- **possible_keys: <font style="color:blue">MySQL 认为可能能用的索引</font>**, 但最终用不用还是看 key 字段



- ref: **表明索引是怎么被使用的, 比如对比的值是 常量(const) 还是 字段(field) 或者 是和函数结果比较(func)**. 没有使用索引或无法判断就是 NULL



- filtered: 表示返回结果的行数占需读取行数的百分比, 所以 filtered 的值越大越好



# MySQL事务的四个特性

MySQL (以及所有关系型数据库) 中事务的四大特性被称为ACID:

> Atomicity; Consistency; Isolation; Durability

- **原子性: 一个事务必须被视为一个不可分割的工作单元**, 事务中的操作要么全部成功提交, 要么全部失败回滚
- 一致性: 事务执行前后, 数据库都处于**一致状态**, 不会破坏数据的完整性约束. 即**<font style="color:blue">数据库总是从一个一致性状态转换到下一个一致性状态</font>**
- 隔离性: **通常来说, 一个事务所做的修改在最终提交以前, 对其它事务是不可见的**. 所以多个事务可以交叉执行, 数据互相隔离
- **持久性: <font style="color:blue">事务一旦提交, 所做的修改就会被永久保存到数据库中</font>**. 即使系统崩溃数据也不会丢失



# MVCC

## 讲一下MVCC

参考博客: https://www.cnblogs.com/aric2016/p/15779055.html

MVCC 全称是 Multi-Version Concurrency Control, 即多版本并发控制. 可以理解成: **<font style="color:blue">每一行数据都有多个历史版本, 不同事务各看各的版本, 互不打扰</font>**

**如果没有 MVCC 的话, 事务之间的并发就只能靠加锁**, 比如加排他锁 / 共享锁. 但加锁的代价比较大, 容易阻塞并且对性能也有影响, 不适合读多写少的系统

- **所以 InnoDB 引擎引入了 MVCC 机制, <font style="color:blue">允许快照读操作不加锁</font>**, 通过读取旧版本数据来实现并发控制



**MVCC 实际上就是通过<font style="color:blue">隐藏字段; undo log 组成的版本链; 以及 ReadView 三者实现的</font>**

先说隐藏字段吧, 在 InnoDB 的聚簇索引中, 每一行会隐含三个字段, 分别是

- row_id: 也就是行 id, **<font style="color:blue">仅在没有显示定义主键或者非空唯一键时存在, 由 InnoDB自动生成</font>**. 它会作为聚簇索引的**隐式主键, 用来唯一地标识一行**
- 第二个是 **trx_id: 用来记录最后一次修改该行的事务 id, 也就是<font style="color:blue">表明了当前版本属于哪个事务</font>**
- 然后是 roll_pointer: 回滚指针, 当**对数据进行改动时, InnoDB 会把旧版本写入到 undo log 中, <font style="color:blue">然后将回滚指针指向这条 undo log, 从而形成版本链</font>**
  - 这样当事务以后要读取旧版本的数据时, 就**能顺着 roll_pointer 找到修改前的数据了**

> 聚簇索引选择规则回顾:
>
> 1. 如果设置了主键, 则 InnoDB 会选择主键作为聚簇索引
> 2. 如果没有主键, 则会选择第一个非空唯一键作为聚簇索引
> 3. 如果以上两个条件都不满足, InnoDB 会自动生成一个长度为 6 个字节的 row_id 作为聚簇索引
>
> 这里能看出来, InnoDB 的每张表一定有聚簇索引, 无一例外



然后再说 undo log 和版本链

undo log 是 InnoDB 用来记录旧数据的地方, 它只用来做两件事:

- 其一是**如果事务失败了要回滚, 那就靠它来把数据还原回去**
- 或者**<font style="color:blue">如果事务在进行快照读操作, 也要靠它来查旧版本的数据</font>**: 也就是说通过读取 undo log 的历史版本数据可以实现不同事务都拥有自己独立的快照数据版本



而版本链其实就是由**多条 undo log 通过 roll_pointer 串联起来的一条链表结构**, **<font style="color:blue">描述的是一条记录的多个历史版本</font>**. **这个版本链的头结点代表的就是当前记录最新的值**

如果当前记录的版本对当前事务不可见, InnoDB 就会通过 roll_pointer 指针沿着该记录的 undo log 版本链向前回溯, 直到找到第一个可见的版本为止. 需要注意的是:

- **INSERT 操作对应的 undo log 没有 roll_pointer 属性, <font style="color:blue">因为该记录并没有更早的版本了</font>**

- **DELETE 操作会记录删除前的整行数据**, 也就是完整地记录了被删除行的所有字段值, **这样才能实现回滚**

- **而 UPDATE 操作的 undo log <font style="color:blue">只需要记录被修改的字段值</font>**, 回滚时只恢复被修改的字段, 其它字段不变



但实际上 undo log 只分为两种类型

**一种是 insert undo log**: 也就是事务在插入新数据时产生的 undo log, 用于事务回滚时撤销插入操作. **<font style="color:blue">因为只在事务回滚时需要, 所以事务提交后可以被立即丢弃</font>**

```mysql
START TRANSACTION;
INSERT INTO users(name) VALUES ('Tom');
ROLLBACK;

# InnoDB 记录了这条插入是我做的, 如果我回滚, 它知道该删掉这一行
# 一旦我提交, 别人也不需要看"插入前是什么", 这条日志就可以删了
```

**另一种就是 update undo log**: 事务在进行 update 或者 delete 操作时产生的 undo log. **<font style="color:blue">它除了要用于事务的回滚, 还要用于快照读, 所以不能随便删除</font>**

- **除非当快照读和事务回滚不涉及该日志时, 对应的 update undo log 才会被 purge 线程统一清除**

> 简单来讲清理条件其实就是: 生成这个 undo log 的事务已经提交; 且系统中没有其他活跃事务需要访问它

```mysql
-- T1 事务
START TRANSACTION;
UPDATE users SET name = 'Tom' WHERE id = 1;

-- T2 并发快照读
SELECT * FROM users WHERE id = 1;  -- 想看到修改前的值

# InnoDB 记录了 id=1 原本的名字, 比如 'Jerry', 写在 undo log 里
# T1 如果回滚, 可以改回去. T2 如果需要旧版本(MVCC 快照), 也能从 undo log 中找到
# 所以 update undo log 要多保留一段时间, 直到所有需要旧版本的事务都结束
```



最后再说 ReadView. **ReadView 其实就是事务中在执行快照读时会创建的一个一致性读视图, 其实相当于一种快照. <font style="color:blue">它决定了当前事务能够看见哪个版本的数据</font>**. 其中包含了四个重要的属性, 分别是:

- **m_ids: <font style="color:blue">表示生成 ReadView 时当前系统中活跃的事务 id 列表</font>**
- min_trx_id: 表示活跃中的最小事务 id, **也就是 m_ids 中的最小值**
- 相对的还有一个 max_trx_id: **<font style="color:blue">表示生成 ReadView 时系统应该分配给下一个事务的 id</font>**
- 最后是 creator_trx_id: 表示生成当前 ReadView 时所在的事务id, **即当前事务 id**



针对这四个属性就有了相应的 **undo log 版本链的访问规则, 这也常被叫做<font style="color:blue">可见性算法</font>**:

[由上至下依次判断]

1. **trx_id = creator_trx_id, <font style="color:blue">是的话说明这个版本的数据是当前事务自己产生的</font>, 因此可以访问**
2. 不满足的话**继续判断 trx_id < min_trx_id**, 是的话就表明**生成该版本的事务在当前事务生成 ReadView 前已经提交**, 所以该版本可以被当前事务访问
3. 否则的话**继续判断 trx_id >= max_trx_id**, 是的话说明**生成该版本的事务在当前事务生成 ReadView 后才开启**, 所以该版本**<font style="color:blue">不能被当前事务访问</font>**
4. 如果依旧不满足条件的话就说明 min_trx_id <= trx_id < max_trx_id, **<font style="color:blue">这种情况下就要判断 trx_id 是否在 m_ids 列表当中了</font>**
   - 在 m_ids 当中的话就说明创建 ReadView 时生成该版本的事务还是活跃的, 所以不能访问
   - 不在 m_ids 中就说明创建 ReadView 时生成该版本的事务已经被提交了, 因此可以访问

最后在经过上述可见性算法的判断过后, **<font style="color:blue">如果某个版本的数据对当前事务不可见的话, 那就顺着版本链找到下一个版本的数据</font>**, 然后继续按照可见性算法判断其可见性, **以此类推直到版本链中的最后一个版本**

- 如果最后一个版本也不可见的话, 那就表明该条记录对当前事务完全不可见, 查询结果也就不包含该记录



另外要注意的是 InnoDB 引擎**只会在 RC (也就是 Read Committed, 读已提交) 和 RR (Repeatable Read, 可重复读) 两种隔离级别下, <font style="color:blue">当事务中执行快照读时</font>**, 会基于 MVCC 做数据的多版本并发控制

- 对于使用 Read Uncommitted 读未提交隔离级别下的事务来说, **由于<font style="color:blue">可以读到未提交事务修改过的记录, 所以直接读取记录的最新版本就可以了</font>**. 而对于使用 Serializable 隔离级别的事务来说, **InnoDB 会使用加锁的方式来访问记录, 因此也不会存在并发问题**



还有就是 MVCC 在 RC 和 RR 两种隔离级别下的表现也有所不同

- **<font style="color:blue">RC 隔离级别下每次快照读都会重新生成一个新的 ReadView</font>**, **而 RR 隔离级别下只有第一次快照读会生成一个 ReadView, <font style="color:blue">之后的快照读会进行复用</font>**
- 因此在同一事务内, RC 隔离级别下可能两次快照读返回的是同一行的不同版本的记录, 而 RR 隔离级别下返回的是相同版本. 这也解释了为什么 RC 下有不可重复读的问题, 而 RR 是可重复读

## MVCC解决了什么样的问题

**<font style="color:blue">最主要的就是解决了读写阻塞问题</font>**. 没有 MVCC 的话当某个事务在修改某行数据时会加一个独占写锁, 而使用当前读的话读和写操作互斥, 会导致并发性能较低

而**快照读根据 MVCC 的规则返回的是某一历史版本数据, 即使可能不是最新记录, 但避免了被阻塞**



其次就是**<font style="color:blue">在 RR 隔离级别下的快照读方面</font>能够避免出现幻读现象**

最后 **MVCC 提供了解决不可重复读的能力, 但只有在 RR 隔离级别下, 才能真正地避免不可重复读**, 因为 RR 隔离级别下的 ReadView 是复用的



# 索引

## MySQL的索引是什么数据结构

在 MySQL 中, **<font style="color:blue">InnoDB 和 MyISAM 存储引擎使用的都是 B+ 树作为索引结构</font>**, 但 InnoDB 支持聚簇索引, 其叶子节点中存放的是整行数据

- **而 MyISAM 并不支持聚簇索引, 其 B+ 树索引的叶子节点中存放的是数据文件的物理地址**, 也就是指针, **<font style="color:blue">指向了 .MYD 数据文件中的偏移量</font>**, 通过这个地址才可以读取整行数据



**其次 MyISAM 和从 MySQL 5.6 版本开始的 InnoDB 引擎也都支持全文索引**, 这是一种通过建立倒排索引结构, 快速匹配文档的方式, 比较适用于大文本的全文检索



另外**还有 Memory 存储引擎默认使用的 Hash 索引**, 底层的数据结构也就是哈希表. 该索引只有精确匹配索引列的等值查询才有效, 并不支持范围查询

- **<font style="color:blue">而 InnoDB 和 MyISAM 引擎都不支持哈希索引</font>**

不过如果 InnoDB 发现: **有很多寻路很长的 SQL** (比如因为 B+ 树层数太多、回表次数多等); **或者有很多 SQL 会命中相同的 Page 的情况时**

- InnoDB 就会**在自己的内存缓冲区** (也就是 Buffer Pool) 中, **<font style="color:blue">开辟一块区域并维护一套自适应的哈希索引 (AHI)</font>**, 用于加速查询



### 为什么是B+树而不是B树

最主要的原因就是**<font style="color:blue">在 B+ 树中, 数据都存储在叶子节点上, 非叶子节点只存储索引信息</font>** (类似于路标); 但**在 B 树中, 数据和索引分布在所有节点上**

这样的**结构也导致了 B+ 树的扇出率更高**, 扇出率就是指一个节点最多能拥有的子节点数量. 而**<font style="color:blue">扇出率越高, 树的层级也就越少, 查找路径越短, 因此也会有更少的 IO 次数</font>**

- B 树因为其节点不仅存 key, 还要存数据. 因此相同情况下扇出率肯定偏低



**<font style="color:blue">此外 B+ 树的叶子节点使用链表相连</font>, 因此对于 B+ 树的范围查询, 只需要对链表进行遍历即可**; 而 B 树中的叶子节点都是独立的. 这一点也使得 B+ 树的范围查询更高效

**其次 B 树的检索过程相当于对范围查询内的每个节点的关键字做二分查找**, 可能还没有到达叶子节点, 检索就结束了; 而**<font style="color:blue">对 B+ 树而言任何查找都是从根节点到叶子节点的过程, 检索效率也就更稳定</font>**



## 聚簇索引和非聚簇索引的区别

聚簇索引是指索引结构和数据一起存放的索引, 也就是说**<font style="color:blue">索引结构中的叶子节点存储的是数据行本身</font>**. **InnoDB 引擎中的主键索引就属于聚簇索引**

- 当**通过聚簇索引查找数据时, 可以直接从索引中获取数据行**, 不需要额外的步骤去查找数据的所在位置

而对于非聚簇索引, InnoDB 引擎中其索引结构中的叶子节点存储的是当前索引列的值和对应的主键值. **所以查找完整数据时, <font style="color:blue">必须通过主键值去聚簇索引中再查一次来找到实际的数据行</font>, 这个操作称之为回表查询**

- 另外 MyISAM 存储引擎和其它一些数据库中的非聚簇索引结构的叶子节点**存储的其实是数据行的物理地址(也就是偏移量)**



其次由于聚簇索引通常是基于主键构建的, 因此**每个表只能有一个聚簇索引, 因为<font style="color:blue">数据只能有一种物理排序方式</font>**; 但一个表**可以有多个非聚簇索引, 因为它们不直接影响数据的物理存储位置**



此外**对于范围查询和排序查询**, 聚簇索引通常更有效率, 因为**<font style="color:blue">它避免了额外的寻址开销</font>**; 而**非聚簇索引在使用覆盖索引进行查询时效率更高, 因为<font style="color:blue">这样不需要读取完整的数据行</font>**

- 但是需要进行回表的操作使用非聚簇索引的效率就比较低了



## 构建索引时的注意事项(怎么决定建立哪些索引)

应该选择合适的字段建立索引: 比如**经常用于 WHERE 查询条件的字段、经常参与排序或分组的字段以及被经常用于表连接的字段, <font style="color:blue">并且也不应该在低区分度的字段上单独建立索引</font>**

- 比如性别 / 状态这种只有几种确定值的字段, 因为查询时命中率太高, 建了索引也起不到什么优化效果
- 还有就是**索引字段的数据应该尽量不为 NULL**, 因为对于数据为 NULL 的字段, 数据库比较难优化

> 如果字段频繁被查询但又避免不了为 NULL, 最好是使用 0、1、true、false 这样语义较为清晰的短值或者短字符作为替代



然后**<font style="color:blue">对于被频繁更新的字段应该慎重建立索引</font>**, 因为虽然**索引能带来查询上的效率提升, 但是维护索引的成本也是不小的**. 如果一个字段不被经常查询, 反而是被经常修改, 那么就不应该在这种字段上建立索引了



其次应该**<font style="color:blue">尽可能地考虑建立联合索引而不是单列索引</font>, 因为索引是要占用磁盘空间的**. 如果是联合索引, 多个字段在一个索引上, 那么将会**节约很多磁盘空间, 并且修改数据时的操作效率也会提升**

同时**也要<font style="color:blue">注意避免冗余索引</font>, 也就是多个索引的功能相同**. 比如能够命中索引 (a, b) 就肯定能命中索引 (a), 那么索引 (a) 就是冗余索引. **在大多数情况下, 都应该<font style="color:blue">尽量扩展已有的索引而不是创建新索引</font>**



**另外也要<font style="color:blue">控制索引的数量, 因为每个索引在写操作时都要同步维护, 会降低 "增删改" 操作的速度</font>**, 而且索引需要占用额外的存储空间. **单表的索引数量一般不超过 5 个**, 而对于复杂的业务场景可以适当放宽



## 使用索引的注意事项(索引失效的情况包含在内)

首先就是要**<font style="color:blue">遵循最左前缀匹配原则:</font>** 也就是对联合索引来说, **<font style="color:blue">必须从最左侧的索引列开始使用才能命中索引</font>**. 比如现在有一个 (a, b, c) 三个列组成的联合索引

+ `WHERE a = 1`、`WHERE a = 1 AND b = 2` 都可以命中索引; 而 `WHERE b = 2` 就不能命中, **因为跳过了联合索引中最左边的列 a**

> 最左前缀原则影响的只是**联合索引能否在 WHERE / ORDER BY / GROUP BY  等子句中是否被有效利用**
>
> 其并不影响 SELECT 关键字后面的字段.  虽然 SELECT 查询的字段不在索引里, 就会回主键索引找完整数据, 但这和最左前缀法则没关系



然后还要**<font style="color:blue">避免对索引列使用函数或者进行表达式运算, 否则索引会失效</font>**

> 不走索引写法案例: `WHERE age + 1 = 30`、`WHERE YEAR(created_time) = 2025`
>
> 后者可以优化写成 `WHERE created_time BETWEEN '2025-01-01' AND '2025-12-31'`



此外也要**<font style="color:blue">避免使用通配符开头的 LIKE 进行模糊匹配</font>**, 比如 `WHERE name LIKE '%abc'` 就不走索引, **因为索引在底层是按照列值有序排列存储的**, MySQL 在查找时会利用从左到右的有序性去做范围查找

而**如果 % 在最前面, 表示前面可以是任意字符, <font style="color:blue">数据库就无法直接通过索引定位到某个范围</font>, 结果也就只能扫描全表**. 如果需要模糊搜索, 可以考虑使用全文索引或者像 Elasticsearch 这样的外部搜索引擎



其次当 **MySQL遇到字符串和数字比较的时候**, 会自动把字符串转为数字, 然后再进行比较. 如果**<font style="color:blue">字符串是索引列, 而条件语句中的输入参数是数字的话</font>, 那么索引列就会发生隐式类型转换**

由于**隐式类型转换是通过 CAST 函数实现的**, 等同于对索引列使用了函数, 因此也会导致索引失效



还有就是在**使用索引时尽量使用覆盖索引**, 也就是查询的字段全部包含在索引当中, 这样就无需进行回表查询

> 覆盖索引示例
>
> ```mysql
> -- 假设 idx(name, age)
> SELECT name, age FROM user WHERE name = 'Tom';
> 
> -- 会回表查询的情况
> -- 查询了不在索引里的 address, 就要回主键索引找原数据
> SELECT name, address FROM user WHERE name = 'Tom';
> ```



最后要注意主键和唯一键默认就有索引, 不要重复创建. 并且最好定期使用 EXPLAIN 命令分析查询是否命中了索引

> 提要 -- 注意 NULL 的处理
>
> MySQL 索引是支持 NULL 的, 比如 `WHERE col IS NULL` 能用到索引. **<font style="color:blue">但在唯一索引里, NULL 不会被当成重复值处理</font>**. 也就是说想实现 NULL 只有零或一个且剩下的也都是唯一值, **MySQL 默认 UNIQUE 做不到**



## 联合索引为什么要满足最左匹配原则

**因为在 MySQL 的 InnoDB 引擎中, 索引是通过 B+ 树实现的**. 假设现在有一个基于 (a, b, c) 三个列的联合索引, 那么它们的排序规则是:

- **<font style="color:blue">先按 a 排序, a 相同再按 b, b 相同再按 c 这样的组合排序</font>**.  B+ 树会以 a 为第一维排序, **B+ 树的联合索引的底层也会按最左字段优先的字典序存储**
- 因此查找必须从最左字段开始, 否则树没法利用有序性去定位范围, 只能退化为全表扫描



# 锁

## 快照读和当前读的区别

快照读就是指事务中在执行 select 语句时, **并不去访问表中的实时数据, <font style="color:blue">而是读取一份快照版本的数据</font>**. 实际上**在 RC 和 RR 两个隔离级别中**不加锁的普通 select 语句都属于快照读

并且快照读也是 InnoDB 引擎默认的读取方式

```mysql
-- T1 开启事务
START TRANSACTION;

-- 查询 user 表的内容
SELECT * FROM users WHERE id = 1;

# 此时 T1 查询的并不是 users 表当前的实时数据, 而是在事务开始那一刻的历史版本
# 即便别的事务此时修改了 id=1 的数据, T1 也看不到
```

快照读的特点就是不加锁, 性能高; 它基于 MVCC 机制实现, 不会阻塞, 也不会被阻塞



而当前读 (也叫加锁读) 是指在读取数据时, **<font style="color:blue">主动给读取的记录加上锁</font>, 阻止其它事务对它进行更新或删除等操作**. 当前读并不基于 MVCC 机制, **<font style="color:blue">读取的就是当前数据的真实版本</font>**

它比较适用于需要判断数据是否存在后再插入 / 更新时的读取. **当前读的语法有两种**:

- **第一种是 `SELECT ... FOR UPDATE`. 这种方式是<font style="color:blue">给查询结果加上排他锁</font>** (也叫 X 锁 -- Exclusive Lock), 加了排他锁之后, **其它事务既不能读取 (这里的读取是指加锁读), 也不能修改或删除这条数据**
  - **<font style="color:blue">但持锁的事务还是可以进行修改或删除操作的</font>**
  - **如果其它事务在尝试修改、删除或者加锁读取时会被阻塞**, 此时就会被迫等待持锁事务释放排他锁. 只有当持锁事务提交或回滚后其它事务才能继续执行
  - 但如果其它事务只是在执行普通的快照读, 那么是可以读取到数据的, 因为读到的是旧版本

- 然后**第二种当前读的语法是 `SELECT ... LOCK IN SHARE MODE`. 这种方式是<font style="color:blue">给查询结果加上共享锁</font>** (也叫 S 锁 -- Shared Lock)

  - 使用这种方式时无论是否是持锁事务, 都只能读取被锁住的行, 并不能修改. 但**在其它事务中也不是随便就能读, <font style="color:blue">它们在读取时也需要加共享锁</font>**, 否则进行的就是快照读

  > 从这里也能看出来: 数据被某个事务获取共享锁之后, 还可以被其它事务获取共享锁, 但不能被其它事务获取排他锁

  - 另外如果持锁事务想要修改数据的话需要将共享锁变成排他锁才行, 但**并不是以叠加加锁的方式**, 而是要进行一个类似于锁升级的过程
    - **但本质上是一次新的加锁操作 -- <font style="color:blue">也就是释放旧锁, 然后重新请求排他锁 + 冲突判断</font>**. InnoDB 引擎会在执行修改操作时, 自动尝试申请排他锁. **并且在这个过程中会进行锁兼容性的检查**
    - 如果当前事务是唯一持有共享锁的事务, 那么就升级成功, 拿到排他锁; **如果别的事务也持有共享锁, 那就升级失败, <font style="color:blue">阻塞等待或者可能触发死锁</font>**



> 最后要注意在 InnoDB 引擎中, 加的锁 (无论是排他锁还是共享锁) 都是事务级的. 也就是说:
>
> - **<font style="color:blue">锁的生命周期 == 事务的生命周期</font>**
> - 一旦事务结束 (不管是提交还是回滚), 所有锁都会被释放



## 什么是意向锁, 意向锁的作用是什么

意向锁是 InnoDB存储引擎中**<font style="color:blue">引入的一种表级锁</font>, 分为意向共享锁 (IS) 和意向排他锁 (IX)**. 它的主要作用就是**协调行级锁和表级锁之间的加锁行为**, 尽量避免遍历全表数据



意向锁的作用可以分成两个方向:

- 其一是**<font style="color:blue">帮助表锁申请者判断是否能加锁</font>**: 也就是当某个事务要对整张表加表级锁时, 不需要遍历所有行去找有没有锁, **只需要判断表上是否已经存在不兼容的意向锁即可**
- 另一个就是**<font style="color:blue">帮助行锁申请者与表锁进行冲突检测</font>**: **当事务要加行锁时, InnoDB 会先在表级申请 IS 或者 IX 锁**. 如果当前表已经被加了不兼容的表级锁, 那么这次行锁的申请就会被阻塞或失败



由此可以看出意向锁的存在既提高了表锁申请时的效率, 也让行锁和表锁之间的冲突检测更加简单高效

> IS 全称 -- Intention Shared; IX 全称 -- Intention Exclusive



## InnoDB是怎么解决幻读问题的

参考博客: https://blog.51cto.com/u_16213654/12174935

**<font style="color:blue">绝大多数情况下</font>**, InnoDB 在 RR (可重复读) 的隔离级别下是可以解决幻读问题的, 解决方案有两种: **其一是使用 MVCC 机制解决了在快照读情况下的幻读**

但在某些比如银行业务等特殊场景中, 是必须要读取到实时数据的, 此时就不能再用快照读了

- 这种情况就需要采用当前读这种加锁的方式. 而**在 InnoDB 的可重复读隔离级别下使用当前读时, 会<font style="color:blue">通过 Next-Key Lock (临键锁) 来解决幻读问题</font>**



**临键锁包含两个部分: 记录锁 (Record Lock), 也就是行锁; 以及间隙锁 (Gap Lock)**

先说记录锁吧, **<font style="color:blue">记录锁是加在索引上的锁</font>**, **因此锁住的永远是索引, 并不包括记录本身**. 即使表中没有任何索引, InnoDB 也会在后台创建一个隐藏的聚簇主键索引, 那么这时锁住的就是这个隐藏的索引



然后再说间隙锁, **<font style="color:blue">间隙锁存在的主要目的就是在 RR 隔离级别下防止幻读</font>**

- 而幻读简单来说就是在同一个事务中, 前后两次相同的查询语句的查询结果数量上下不一致, 因此**间隙锁就是为了保证某个范围内的数据不会被更改, 也就是说会锁住某些个区间的数据**

间隙锁不同于记录锁, 它是对索引前后的间隙上锁, 并不会对索引本身加锁, **加锁区间是左开右开**. 但由于间隙锁是加在索引之间的, 所以**<font style="color:blue">也必须基于索引结构才能工作</font>**

**另外当<font style="color:blue">对于没有索引的列使用当前读操作时, InnoDB 会退化为全表扫描, 并在聚簇索引上加锁</font>**. 匹配到的行会被加记录锁, **同时可能伴随着大范围的间隙锁**, 导致并发性能下降, 因此实际开发中要尽量避免



其次**对于主键或者唯一索引的等值查询 (也就是使用 = 或 IN), <font style="color:blue">且命中的记录确实存在时</font>**. 由于唯一性约束, 其它事务无法插入相同的键值, 因此不存在幻读风险

- 此时 InnoDB 的当前读**<font style="color:blue">也只会对这些记录加记录锁, 不会再加间隙锁</font>**

但对于 "当前读 + 范围查询" 的操作 (也就是 where 条件中使用 >、<、like 等时), 默认是添加临键锁的, **而临键锁是索引记录上的行锁和索引之间的间隙锁的组合, 包括记录本身**

- **<font style="color:blue">因此临键锁的加锁区间是左开右闭的</font>**



接下来结合这些结论举个例子

```markdown
假设有一张表, 其中有五条数据, 它们的 id 分别是 5, 10, 15, 20, 25
然后现在列举几种条件查询的情况

1. where id > 9, 它锁住的区间简单来说就是 (5, +∞), 开头是 5 而不是 9 是因为 9 并不存在, 并且刚才提到过加锁是要基于索引的, 没有索引无法加锁
> 细致一点说 InnoDB 其实会锁住 (5, 10], (10, 15], (15, 20], (20, 25], (25, +∞) 多个区间. 5 到 正无穷只不过是一种简化写法

2. where id > 9 and id < 18, 它锁住的区间就是 (5, 10]; (10, 15]; (15, 20]
	- 这里由于加的就是临键锁, 所有加锁区间都是左开右闭的, 因此 20 也在锁住的区间内
	
3. where id = 10, 它就只会锁住 id 为 10 的这一条数据

4. where id = 7, 因为 7 并不存在，但是还要防止后续新增，所以也要锁住最近的一个区间 (5, 10)
	- 此外因为 id = 7 的查询并没有命中任何记录, InnoDB 无法确定哪条记录要加行锁 (也就是记录锁), 所以它只会加间隙锁, 也因此加锁区间是左开右开的. 而记录锁只有在记录被命中时才会有
```



最后要注意的就是**可重复读的隔离级别下确实可以很大程度上避免幻读, <font style="color:blue">但是还是不能完全解决幻读问题</font>**. 举一个可重复读隔离级别下发生幻读现象的场景吧

- 假设现在有一个表中有 id 分别为 1, 2, 3, 4 的四条数据. 然后有一个事务 A 执行查询 id = 5 的记录, 此时的表中是没有该记录的, 所以查询不出来
- 然后另一个事务 B 插入了一条 id = 5 的记录, 并且提交了事务
- 此时事务 A 再去更新 id = 5 这条记录. 没错, 事务 A 确实看不到 id = 5 这条记录, 但 ReadView 并不能阻止事务 A 执行 update 或 delete 语句来改动这个新插入的记录
  - 并且由于事务 B 已经提交, 因此改动该记录并不会造成阻塞, 这样**这条新记录的 trx_id 隐藏列的值就变成了事务 A 的事务 id**
- 之后事务 A 再使用普通的 select 语句去查询这条记录时, 就可以看到这条记录了, 也就是说发生了幻读

> 此时能看到新记录的原因就是可见性算法的第一条规则, 即 trx_id = creator_trx_id

这个场景确实很违和, 但幻读有时就是发生在这种违和的场景下. 也因为这种特殊现象的存在, 所以我们可以认为 InnoDB 中的 MVCC 机制并不能完全避免幻读



> 注: (1) RR 隔离级别下才有间隙锁, RC 隔离级别下没有间隙锁
>
> 
>
> (2) 此外针对最后一段话中的案例, 这是小林 coding 中给出的一个例子. 但 GPT 认为这个例子并不属于标准意义上的幻读 (包括此问题的参考博客中列举的另一个案例, GPT 也认为不属于幻读)
>
> 原因就是它们都切换了读时的语义. GPT 认为小林 coding 中案例的 update 部分, 就相当于使用了当前读, 因此属于"读语义切换". 参考博客中的另一个案例更是如此 (先快照读, 后使用当前读)
>
> 这里引用一句 GPT 给出的原文 -- "RR 隔离级别且在各自一致的语义下 (纯快照读、纯当前读) 是能避免幻读的". 换句话说我在文中给出的幻读的定义, GPT 认为还要加上 "相同的读语义" 这个限制条件
>
> 
>
> 不过我在牛客上看到针对这个问题的讨论大家的说法基本还是 "可以部分解决", 但是大家给出的反例其实跟小林 coding 以及我给出的参考博客中的反例一致 (可能也因为这就是大部分人的参考来源)
>
> 所以我最终在此问题中还是保留了这一段的反例



# 不常考问题

## blob和text的区别

**BLOB 用于存储二进制数据 (如图片 / 音频 / 视频 / 压缩文件等)**, 这种类型不进行字符集转换或排序, 因此也不受字符编码的限制

**TEXT 用于存储大量文本数据 (例如文章内容 / 长文本等)**, 数据在存储时会根据定义的字符集进行编码, 根据指定的字符集进行存储和排序, 并且在排序或比较时也会使用该字符集

> BLOB 类型不支持字符集相关的排序(collation 排序), 但可以按照字节值进行原始排序. 即**<font style="color:blue">排序时是按每个字节的二进制值从左到右比较</font>**
>
> 一旦某个字节能分出大小, 就立即返回排序结果; 若前缀一致, 则较短的字节数组排在前



另外由于BLOB存储的是二进制数据, 所以**<font style="color:blue">它不支持常规的字符串操作函数</font>**. **对于BLOB数据的操作通常限于插入 & 更新 & 删除及等值匹配等二进制级别的检索**

**<font style="color:blue">TEXT 支持大多数字符串操作函数</font>**, 例如 `CONCAT` / `SUBSTRING` / `LENGTH` 等. **此外 TEXT 数据可以使用 LIKE 操作符进行模糊匹配查询, 并支持全文搜索**



在进行数据库备份时, BLOB 数据可能会占用大量的存储空间, 特别是当存储大量的图像或视频文件时. 因此对于数据库管理而言, 可能需要采取特殊的策略来处理这些大文件

- 比如 **BLOB 存储外部化: 也就是将图片 / 视频等数据存储在对象存储服务中(如阿里云OSS / 亚马逊S3), 数据库中只存路径或URL** -- 减少数据库体积、加快备份和恢复

虽然 TEXT 数据同样可以非常大, 但由于其是字符串格式, 因此在备份和恢复时更为直接



> BLOB 和 TEXT 都有四种子类型, 分别用于存储不同大小的数据. 它们分别是:
>
> TINYBLOB / TINYTEXT: 最大存储容量为 255 字节
> BLOB / TEXT: 最大存储容量为 65,535 字节 (即 64 KB)
> MEDIUMBLOB / MEDIUMTEXT: 最大存储容量为 16,777,215 字节 (即 16 MB)
> LONGBLOB / LONGTEXT: 最大存储容量为 4,294,967,295 字节 (即 4 GB)































