# session和cookie的区别

首先它们的**<font style="color:blue">存储位置不同</font>**

- **Cookie 存储在客户端浏览器**中 (由服务器通过响应头 Set-Cookie 下发)
- **Session 存储在服务器端, <font style="color:blue">浏览器只保存一个 Session ID</font>** (这个 ID 通常存在 Cookie 中)



然后它们的**作用机制也不同**

- **浏览器每次请求都会<font style="color:blue">自动携带 Cookie 给服务器</font>**, 可用于身份识别 / 保持登录状态等场景
- 对于 Session 来说, 服务器会**根据浏览器携带的 Session ID 查找**服务端对应的用户会话数据



在**安全性比较上**

- **Session 更安全, 因为<font style="color:blue">数据保存在服务器</font>, 客户端只能拿到 Session ID**, 无法直接篡改会话内容
- 而 **Cookie 相对来说更容易被盗取或篡改**, 常见方式有 XSS 窃取或者网络监听
  - 不过可以通过设置 HttpOnly / Secure 等属性降低风险




此外它们的**存储大小限制也不同**

- **<font style="color:blue">单个 Cookie 限制为 4KB</font>**, 并且**<font style="color:blue">浏览器对单个域名可存储的 Cookie 数量也有限制</font>** (早期限制为 20 个, 不过现代浏览器已经可以存放几十甚至上百个了)
- 而对于 Session 来说, **理论上<font style="color:blue">存储上限取决于服务器内存</font>, 能够存储较多数据**
  - 不过虽然能存很多, 也不应该把太多业务数据都放到 Session 中, 这样做会占用服务器内存影响性能




最后是**生命周期的不同**

- Cookie 可以**通过 `cookie.setMaxAge(秒)` 来设置过期时间**, **<font style="color:blue">不过默认是浏览器关闭就失效</font>**

- 而 Session 一般在**浏览器关闭**(会话级 Cookie 丢失, 导致无法找到原来的 Session)、用户退出(**后端应用一般会调用 `session.invalidate()` 来销毁会话**) 或者 **<font style="color:blue">服务器配置的超时时间到达后失效</font>**

  - **<font style="color:blue">超时时间默认是 30 分钟</font>**, 不过**准确的说是"非活动超时时间"**, 就是如果这段时间内用户没有发送任何请求 服务器才会自动销毁 Session

    - 这与 Cookie 的固定过期时间不同: **<font style="color:blue">Cookie 是过了过期时间就会失效</font>**

  - 有三种设置非活动超时时间的方式: (application.yml 和 web.xml 中的是全局配置)

    -  `setMaxInactiveInterval(15 * 60)`: 单位是秒, **但它只是设置当前这个用户对应的 Session 对象的非活动超时时间, 而非全局的 Session** (另外如果传递的参数是 -1 就代表永不失效)
    -  application.yml 中配置

    ```yml
    server:
      servlet:
        session:
          timeout: 30m # 设置为 30 分钟, 支持 s/m/h/d（秒/分钟/小时/天）
    ```

    - web.xml 配置(传统 Servlet 项目)

    ```xml
    <session-config>
        <session-timeout>30</session-timeout> <!-- 单位是分钟 -->
    </session-config>
    ```

# 常见的http状态码

1XX: 信息性状态码. 请求已接收, 服务器正在处理中, 需客户端继续操作

- **100 Continue: 服务器已收到请求的一部分, 客户端应继续发送请求的其余部分**
- 101 Switching Protocols: 表示服务器将切换至新的协议. 比如浏览器请求升级到 WebSocket 协议, 服务器确认切换



2XX: 成功状态码

- **<font style="color:blue">200 OK: 请求成功, 返回所请求的资源</font>**
- 201 Created: 请求成功且服务器已创建新资源. 可以用于 POST / PUT 创建资源之后的场景
- 204 No Content: 请求成功，但没有返回任何内容



3XX: 重定向状态码. 表示需要进一步操作才能完成请求

- **<font style="color:blue">301 Moved Permanently: 资源永久移动到新URL, 浏览器自动跳转, 并更新缓存</font>**
- **302 Found: 临时重定向, 资源临时移动到新URL, <font style="color:blue">未来可能恢复原地址</font>**
  - 比如维护期间, 访问主页跳转到临时维护页面. 不会缓存新地址
- **<font style="color:blue">304 Not Modified: 表示资源未修改</font>**, **客户端可以使用缓存内容**
  - 可以理解成客户端发送请求时告诉服务器: **"我上次缓存了资源, 如果没变就告诉我, 不用重新发内容"**



4XX: 客户端错误类状态码. 表示请求有误, 服务器无法处理

- 400 Bad Request: 请求无效, 客户端发送的数据不符合规范
  - 造成原因: 参数校验失败(如请求缺少必填参数 / 类型不符);  JSON 格式错误等**<font style="color:blue">语法层面的错误</font>**
- 401 Unauthorized: 未授权, 缺少认证凭证或认证凭证无效
  - 造成原因: 没有携带 JWT token 或者 token 令牌过期; 访问需要登录的接口但未登录等
  - 和 403 的区别是: 401 是**你没登录**, 403 是**你登录了但没权限**
- **403 Forbidden: 被禁止访问, 即使认证了也没有权限**
  - 造成原因: 登录用户访问了没有权限的接口; IP被黑名单封禁等
  - 常出现在 RBAC 权限校验失败的情况
- 404 Not Found: 请求的资源不存在, URL 写错了导致资源找不到
  - 相似的是 410 Gone: 表示资源永久不可用, 已被删除
- **405 Method Not Allowed: 请求方法不被允许. <font style="color:blue">比如用 POST 请求了只支持 GET 的接口</font>**
- 429 Too Many Request: 客户端发送请求过多, 触发限流
  - 高频请求接口, 如验证码或短信接口; 短时间内多次调用天气 API, 被限制访问等



5XX: 服务端错误类状态码. 表示服务器在处理请求时发生错误

- 500 Internal Server Error: 服务器内部错误, 执行请求时发生未捕获异常
  - **代码中的 bug 最经常会导致出现这个状态码**
- 502 Bad Gateway: 服务器作为网关或代理时, **<font style="color:blue">接收到了无效响应</font>**
  - 反向代理服务器转发请求后无法从后端获取有效响应, 比如服务没启动等
- 503 Service Unavailable: 服务器过载或维护, 暂时无法处理请求
  - 示例: 网站因流量过大显示"服务不可用, 请稍后再试"
- 504 Gateway Timeout: 服务器作为网关或代理时, 等待后端响应超时
  - API 请求因后端处理超时, 会返回网关超时". 比如: Nginx 等待后端响应时间过长
  - 和 502 不同, 504 是**请求送到了服务端, 但没及时收到响应导致的**































